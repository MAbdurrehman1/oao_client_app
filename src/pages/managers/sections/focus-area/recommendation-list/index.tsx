import { Suspense, useEffect, useMemo, useState } from 'react'
import { lazyWithPreload as lazy } from 'react-lazy-with-preload'

import { Loading } from '@/components/loading'
import { Button } from '@/components/ui/button'
import { useLayoutContext } from '@/hooks/use-layout-context'
import { useTailwindBreakpoint } from '@/hooks/use-tailwind-breakpoint'
import { useReportData } from '@/pages/managers/hooks/use-report-data'
import { SectionsEnum } from '@/pages/managers/types'
import { type KPI, type Recommendation } from '@/types'

import { RecommendationListCard } from './card'
import { type WrapperProps } from './common'

const RecommendationListDesktopWrapperLoader = lazy(() =>
  import(
    /* webpackChunkName: "recommendation-list-wrapper" */ './desktop-wrapper'
  ).then((m) => ({
    default: m.RecommendationListDesktopWrapper,
  })),
)

const RecommendationListMobileWrapperLoader = lazy(() =>
  import(
    /* webpackChunkName: "recommendation-list-mobile-wrapper" */ './mobile-wrapper'
  ).then((m) => ({
    default: m.RecommendationListMobileWrapper,
  })),
)

/**
 *  Figma Design docs
 *
 *  The drawer acts as a library for content created by the Ai within each of the focus areas.
 *  The flow is as follows:
 *    Drawer is not visible until the first recommendation is generated by the Ai,
 *    it can then be edited by the user and finally ‘saved’.
 *    The saving triggers the drawer to slide up from bottom of the window,
 *    the first recommendation then appear in this library.
 *    The drawer then automatically minimises to a tab at the bottom edge,
 *    a small counter shows how many recommendations are saved.
 *
 *    Hover on the tab should partially reveal the drawer as a tease.
 *    A click would trigger this to open up fully.
 *
 *    When the user moves from one focus area,
 *    the drawer disappears and a new drawer is used in the following section.
 *
 *     On touch screen devices this can be associated with drag gestures/swipe up.
 *     check out `mobile-wrapper.tsx` for more details
 */
export const RecommendationList = ({
  kpi,
  items,
}: {
  kpi: KPI | null
  items: Recommendation[]
}) => {
  // recommendations in context, needed for handling next page.
  const { recommendations: allRecommendations } = useReportData()
  const contextRecommendations = kpi ? allRecommendations[kpi] : null
  // this state saves recommendations locally, to defer if a new item is added to recommendations
  const [recommendations, setRecommendations] = useState<Recommendation[]>([])
  // this state saves kpi locally, to defer if recommendations change is based on opne/close if accordion
  // or there's actually a change in recommendations
  const [selectedKpi, setSelectedKpi] = useState<string | null>(kpi)
  // activeSection is a scrollSpy on layout context
  const { activeSection } = useLayoutContext()
  // this state changes with user interactions with the sheet trigger button
  const [sheetOpenedByUser, setSheetOpenedByUser] = useState<boolean>(false)
  // this state for the automated open/close when adding a new recommendation
  // we can't solely depend on sheetOpen state, bc if the user opens the list
  // within two seconds of openning the accordion, a race condtion will happen
  // and the list will be closed.
  const [isShowingFirstRecommendation, setIsShowingFirstRecommendation] =
    useState<boolean>(false)

  // based on the design the sheet should be only visible if user has openned an
  // accordion item, and there's atleat one recommendation.
  // if users scroll to other sections, the sheet must not be visible.
  const shouldSheetBeVisible = useMemo(
    () =>
      activeSection === SectionsEnum.FOCUS_AREA && !!kpi && items.length > 0,
    [activeSection, items.length, kpi],
  )

  // this useEffect exists for the handling the automated
  // openning and closing of the sheet, when the first
  // recommendation is saved to library.
  useEffect(() => {
    // if the kpi has changed, update reccomendations
    // this means either another accordion is opened, or user just opened an accordion.
    if (selectedKpi !== kpi) {
      setSelectedKpi(kpi)
      setRecommendations(items)
    }
    // if the kpi is the same and items are changed, update reccomendations
    if (kpi === selectedKpi && recommendations.length !== items.length) {
      setRecommendations(items)
      // open the sheet when the first recommendation is saved to library.
      // if the recommendation is only created it will have a `localId` instead of an `id`.
      if (items.length === 1 && !!items[0].localId) {
        setIsShowingFirstRecommendation(true)
      }
    }
    // close the sheet after 2 seconds
    // when the first recommendation is saved to library.
    const timeoutId = setTimeout(() => {
      items.length === 1 && setIsShowingFirstRecommendation(false)
    }, 2000)
    return () => clearTimeout(timeoutId)
    // we only need kpi and items changes for this hook
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [items, kpi])

  useEffect(() => {
    // when active section changes, or the opened accordion is closed,
    // if the sheet is open, close it.
    if (sheetOpenedByUser && !shouldSheetBeVisible) {
      setSheetOpenedByUser(false)
    }
  }, [shouldSheetBeVisible, sheetOpenedByUser])
  const isSheetOpen = useMemo(
    () => sheetOpenedByUser || isShowingFirstRecommendation,
    [isShowingFirstRecommendation, sheetOpenedByUser],
  )
  const isMobile = useTailwindBreakpoint({ mode: 'max', breakpoint: 'md' })
  const Wrapper = isMobile
    ? RecommendationListMobileWrapperLoader
    : RecommendationListDesktopWrapperLoader
  const props: Omit<WrapperProps, 'children'> = {
    kpi,
    itemsLength: items.length,
    shouldSheetBeVisible,
    sheetOpenedByUser,
    isSheetOpen,
    setSheetOpenedByUser,
  }
  return (
    <Suspense fallback={null}>
      <Wrapper {...props}>
        {items.map((recommendation) => (
          <RecommendationListCard
            key={recommendation.id ?? recommendation.localId}
            className={!isSheetOpen ? 'pointer-events-none' : ''}
            {...recommendation}
          />
        ))}
        {contextRecommendations && contextRecommendations.hasMore && (
          <div className="flex items-center justify-center">
            <Button
              className="h-8 space-x-2"
              disabled={contextRecommendations.isLoading}
              onClick={() => contextRecommendations.getNextPage()}
            >
              {contextRecommendations.isLoading && <Loading inline />}
              <span>
                {contextRecommendations.isLoading ? 'Loading' : 'Load More'}
              </span>
            </Button>
          </div>
        )}
        <div className="shrink-0 grow-0 basis-s24" />
      </Wrapper>
    </Suspense>
  )
}
